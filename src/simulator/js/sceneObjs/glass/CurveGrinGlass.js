/*
 * Copyright 2024 The Ray Optics Simulation authors and contributors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import BaseGrinGlass from '../BaseGrinGlass.js';
import i18next from 'i18next';
import Simulator from '../../Simulator.js';
import geometry from '../../geometry.js';
import { Bezier } from 'bezier-js';

/**
 * Gradient-index glass of the shape of a polygon
 * 
 * Tools -> Glass -> Gradient-index polygon
 * @class
 * @extends BaseGrinGlass
 * @memberof sceneObjs
 * @property {PolyBezier} polyBezier - The curve path around the glass generated by the points in a finished path.
 * @property {Array<Bezier>} curves - The curves which make up the path
 * @property {Array<Point>} path - The path of the glass. Each element is an object with `x` and `y` properties for coordinates.
 * @property {boolean} notDone - Whether the user is still drawing the glass.
 * @property {string} refIndexFn - The refractive index function in x and y in LaTeX format.
 * @property {Point} origin - The origin of the (x,y) coordinates used in the refractive index function.
 * @property {number} stepSize - The step size for the ray trajectory equation.
 * @property {number} intersectTol - Tolerance for intersection calculations.
 */
class CurveGrinGlass extends BaseGrinGlass {
  static type = 'CurveGrinGlass';
  static isOptical = true;
  static supportsSurfaceMerging = true;
  static serializableDefaults = {
    curves: [],
    path: [],
    notDone: false,
    refIndexFn: '1.1+0.1\\cdot\\cos\\left(0.1\\cdot y\\right)',
    origin: { x: 0, y: 0 },
    stepSize: 1,
    intersectTol: 1.001e-1,
    rayLen: 0.001
  };
  
  populateObjBar(objBar) {
    objBar.setTitle(i18next.t('main:tools.CurveGrinGlass.title'));
    super.populateObjBar(objBar);
  }

  draw(canvasRenderer, isAboveLight, isHovered) {
    const ctx = canvasRenderer.ctx;
    const ls = canvasRenderer.lengthScale;

    if (this.notDone) {
      if (this.path.length === 2 && this.path[0].x === this.path[1].x && this.path[0].y === this.path[1].y) {
        ctx.fillStyle = 'rgb(255,0,0)';
        ctx.fillRect(this.path[0].x - 1.5 * ls, this.path[0].y - 1.5 * ls, 3 * ls, 3 * ls);
        return;
      }
      
      // The user has not finish drawing the object yet
      ctx.beginPath();
      ctx.moveTo(this.path[0].x, this.path[0].y);

      for (var i = 0; i < this.path.length - 1; i++) {
        ctx.lineTo(this.path[(i + 1)].x, this.path[(i + 1)].y);
      }
      ctx.globalAlpha = 1;
      ctx.strokeStyle = 'rgb(128,128,128)';
      ctx.lineWidth = 1 * ls;
      ctx.stroke();
    } else {
      // The user has completed drawing the object
      ctx.beginPath();
      ctx.moveTo(this.path[0].x, this.path[0].y);

      for (var i = 0; i < this.path.length; i++) {
        this.drawCurve(this.curves[i], this.path[i], canvasRenderer);
        //this.drawCurve(this.curves[i], this.path[i], canvasRenderer);
        //ctx.bezierCurveTo(this.controlPoints[i].x, this.controlPoints[i].y, this.controlPoints[(i + 1)].x, this.controlPoints[(i + 1)].y, this.path[(i + 1)].x, this.path[(i + 1)].y);
        //ctx.lineTo(this.path[(i + 1) % this.path.length].x, this.path[(i + 1) % this.path.length].y);
      }
      this.fillGlass(canvasRenderer, isAboveLight, isHovered);
    }
    ctx.lineWidth = 1;


    if (isHovered) {
      for (var i = 0; i < this.path.length; i++) {
        ctx.fillStyle = 'rgb(255,0,0)';
        ctx.fillRect(this.path[i].x - 1.5 * ls, this.path[i].y - 1.5 * ls, 3 * ls, 3 * ls);
      }
    }
  }

  move(diffX, diffY) {
    for (var i = 0; i < this.path.length; i++) {
      this.path[i].x += diffX;
      this.path[i].y += diffY;
    }
    this.generatePolyBezier();
  }

  onConstructMouseDown(mouse, ctrl, shift) {
    const mousePos = mouse.getPosSnappedToGrid();
    if (!this.notDone) {
      // Initialize the construction stage
      this.notDone = true;
      this.path = [{ x: mousePos.x, y: mousePos.y }];
    }

    if (this.path.length > 3 && mouse.snapsOnPoint(this.path[0])) {
      // Clicked the first point
      this.path.length--;
      this.notDone = false;

      this.generatePolyBezier();
      return {
        isDone: true
      };
    }
    this.path.push({ x: mousePos.x, y: mousePos.y }); // Create a new point
  }

  onConstructMouseMove(mouse, ctrl, shift) {
    const mousePos = mouse.getPosSnappedToGrid();
    this.path[this.path.length - 1] = { x: mousePos.x, y: mousePos.y }; // Move the last point
  }

  onConstructUndo() {
    if (this.path.length <= 2) {
      return {
        isCancelled: true
      };
    } else {
      this.path.pop();
    }
  }

  checkMouseOver(mouse) {
    let dragContext = {};

    var click_lensq = Infinity;
    var click_lensq_temp;
    var targetPoint_index = -1;
    var targetPoint_subindex = -1;

    // Dragging the entire this
    const mousePos = mouse.getPosSnappedToGrid();
    dragContext.mousePos0 = mousePos; // Mouse position when the user starts dragging
    dragContext.mousePos1 = mousePos; // Mouse position at the last moment during dragging
    dragContext.snapContext = {};

    for (var i = 0; i < this.curves.length; i++) {
      if (mouse.isOnPoint(this.path[i])) {
        click_lensq_temp = geometry.distanceSquared(mouse.pos, this.path[i]);
        if (click_lensq_temp <= click_lensq) {
          click_lensq = click_lensq_temp;
          targetPoint_index = i;
        }
      }
      for (var j = 1; j < 3; j++) {
        if (mouse.isOnPoint(this.curves[i].points[j])) {
          click_lensq_temp = geometry.distanceSquared(mouse.pos, this.curves[i].points[j]);
          if (click_lensq_temp <= click_lensq) {
            click_lensq = click_lensq_temp;
            targetPoint_index = i;
            targetPoint_subindex = j;
          }
        }
      }
    }
    if (targetPoint_index != -1) {
      if (targetPoint_subindex != -1) {
        dragContext.part = targetPoint_subindex + 1;
        dragContext.index = targetPoint_index;
        dragContext.targetPoint = this.curves[targetPoint_index].points[targetPoint_subindex];
        return dragContext;
      } else {
        dragContext.part = 1;
        dragContext.index = targetPoint_index;
        dragContext.targetPoint = this.path[targetPoint_index];
        return dragContext;
      }
    }
    for (var i = 0; i < this.curves.length; i++) {
      if (mouse.isOnCurve(this.curves[i])) {
          // Dragging the entire this
          /*const mousePos = mouse.getPosSnappedToGrid();
          dragContext.mousePos0 = mousePos; // Mouse position when the user starts dragging
          dragContext.mousePos1 = mousePos; // Mouse position at the last moment during dragging
          dragContext.snapContext = {};*/
          dragContext.part = 0;
          return dragContext;
      }
    }
  }

  onDrag(mouse, dragContext, ctrl, shift) {
    var mousePos;
    var mod = 0;
    var closest = { x: 0, y: 0 };

    if (shift) {
      mod++;
    }
    if (ctrl) {
      mod += 2;
    }

    if (dragContext.part === 1) {
      switch (mod) {
        default:
          mousePos = mouse.getPosSnappedToGrid();
          dragContext.snapContext = {}; // Unlock the dragging direction when the user release the shift key
          break;
        case 1, 3:
          mousePos = mouse.getPosSnappedToDirection(dragContext.mousePos0, [{ x: 1, y: 0 }, { x: 0, y: 1 }], dragContext.snapContext);
          break;
        case 2:
          if (geometry.distance(this.path[(dragContext.index - 1 + this.path.length) % this.path.length], this.path[dragContext.index]) < geometry.distance(this.path[(dragContext.index + 1) % this.path.length], this.path[dragContext.index])) {
            closest = this.path[(dragContext.index - 1 + this.path.length) % this.path.length];
          } else {
            closest = this.path[(dragContext.index + 1) % this.path.length];
          }
          mousePos = mouse.getPosSnappedToDirection(geometry.point(closest.x, closest.y), [{ x: 1, y: 0 }, { x: 0, y: 1 }], dragContext.snapContext);
          break;
      }
      this.path[dragContext.index].x = mousePos.x;
      this.path[dragContext.index].y = mousePos.y;
      this.curves[dragContext.index].points[0] = geometry.point(mousePos.x, mousePos.y);
      this.curves[(dragContext.index - 1 + this.curves.length) % this.curves.length].points[3] = geometry.point(mousePos.x, mousePos.y);
      this.curves[dragContext.index].update();
      this.curves[(dragContext.index - 1 + this.curves.length) % this.curves.length].update();
    }

    else if (dragContext.part === 2 || dragContext.part === 3) {
      if (shift) {
        mousePos = mouse.getPosSnappedToDirection(dragContext.mousePos0, [{ x: 1, y: 0 }, { x: 0, y: 1 }], dragContext.snapContext);
      } else {
        mousePos = mouse.getPosSnappedToGrid();
        dragContext.snapContext = {}; // Unlock the dragging direction when the user release the shift key
      }
      this.curves[dragContext.index].points[dragContext.part - 1] = geometry.point(mousePos.x, mousePos.y);
      this.curves[dragContext.index].update();
    }

    else if (dragContext.part === 0) {
      if (shift) {
        mousePos = mouse.getPosSnappedToDirection(dragContext.mousePos0, [{ x: 1, y: 0 }, { x: 0, y: 1 }], dragContext.snapContext);
      } else {
        mousePos = mouse.getPosSnappedToGrid();
        dragContext.snapContext = {}; // Unlock the dragging direction when the user release the shift key
      }
      this.move(mousePos.x - dragContext.mousePos1.x, mousePos.y - dragContext.mousePos1.y);
      dragContext.mousePos1 = mousePos;
    }
  }


  checkRayIntersects(ray) {
    if (this.notDone) { return; }
    if (!this.fn_p) {
      this.initFns();
    }
    if (this.isInsideGlass(ray.p1) || this.isOnBoundary(ray.p1)) // if the first point of the ray is inside the circle, or on its boundary
    {
      this.rayLen = geometry.distance(ray.p1, ray.p2);
      let x = ray.p1.x + (this.stepSize / this.rayLen) * (ray.p2.x - ray.p1.x);
      let y = ray.p1.y + (this.stepSize / this.rayLen) * (ray.p2.y - ray.p1.y);
      const intersection_point = geometry.point(x, y);
      if (this.isInsideGlass(intersection_point)) // if intersection_point is inside the circle
        return intersection_point;
    }

    var s_lensq = Infinity;
    var s_lensq_temp;
    var s_point = null;
    var s_point_temp = null;
    var s_point_index = -1;
    var rp_temp = { x: Infinity, y: Infinity };
    var rp_temp2;
    var intersections = null;
    var scaled_ray = ray;

    for (var i = 0; i < this.path.length; i++) {
      //rp_temp = { x: NaN, y: NaN }; // Reset and populate rp_temp
      s_point_temp = null;

      // Scale ray to ensure it is long enough to intersect the curve before checking for intersection using BezierJS's curve.lineIntersects function
      scaled_ray = geometry.scaleRayForCurve(ray, this.curves[i]);

      // Get the closest point of intersection to the first point of the ray on the current curve
      intersections = this.curves[i].lineIntersects(scaled_ray);//, this.intersectTol);
      if (intersections.length >= 1) {
        // Go through each of them, get the intersection point closest to p1, since it comes sorted by coordinate
        //rp_temp = this.curves[i].get(intersections[0]);
        //console.log("Intersection: " + intersections[0]);

        intersections.forEach((intersection) => {
          rp_temp2 = this.curves[i].get(intersection);
          //console.log("cRI cur rp_temp2: " + rp_temp2.x + ", " + rp_temp2.y + "\n\tt: " + intersection + "\n\t" + rp_temp2);
          if (geometry.distance(geometry.point(rp_temp2.x, rp_temp2.y), scaled_ray.p1) < geometry.distance(geometry.point(rp_temp.x, rp_temp.y), scaled_ray.p1)) {
            rp_temp = rp_temp2;
            rp_temp = geometry.point(rp_temp.x, rp_temp.y);
          }
        });
        console.log("cRI intersections:\n\tLength: " + intersections.length + "\n\tFirst point: " + rp_temp.x + ", " + rp_temp.y);
      
        //Line segment i->i+1
        //var rp_temp = geometry.linesIntersection(geometry.line(ray.p1, ray.p2), geometry.line(this.path[i % this.path.length], this.path[(i + 1) % this.path.length]));
        // Curve i

        //if (geometry.intersectionIsOnCurve(rp_temp, this.curves[i], this.intersectTol) && geometry.intersectionIsOnRay(rp_temp, ray) && geometry.distanceSquared(ray.p1, rp_temp) > Simulator.MIN_RAY_SEGMENT_LENGTH_SQUARED * this.scene.lengthScale * this.scene.lengthScale) {
        if (geometry.intersectionIsOnRay(rp_temp, scaled_ray) && geometry.distanceSquared(scaled_ray.p1, rp_temp) > Simulator.MIN_RAY_SEGMENT_LENGTH_SQUARED * this.scene.lengthScale * this.scene.lengthScale) {
          s_lensq_temp = geometry.distanceSquared(scaled_ray.p1, rp_temp);
          s_point_temp = rp_temp;
        }
      } 

      if (s_point_temp && (!s_point || geometry.distance(geometry.point(s_point.x, s_point.y), ray.p1) > geometry.distance(geometry.point(s_point_temp.x, s_point_temp.y), ray.p1))) {
        if (s_lensq_temp < s_lensq) {
          s_lensq = s_lensq_temp;
          s_point = s_point_temp;
          s_point_index = i;
        }
      }
    }
    if (s_point) {
      this.tmp_i = s_point_index;
      return s_point;
    }
  }

  onRayIncident(ray, rayIndex, incidentPoint, surfaceMergingObjs) {
    if (!this.fn_p) {
      // This means that some error has been occuring eariler in parsing the equation.
      return {
        isAbsorbed: true
      };
    }
    try {
      this.error = null;
      //console.log("Checking incident...");
      // If incidentPoint is not null, then that means that checkRayIntersects returned a non-null s_point, which can only be acquired for this object by there existing at least one intersection point. Hence we need not check if isOnBoundary, but instead whether or not incidentPoint is null.
      //if ((this.isInsideGlass(ray.p1) || this.isOutsideGlass(ray.p1)) && this.isOnBoundary(incidentPoint)) // if the ray is hitting the circle from the outside, or from the inside (meaning that the point incidentPoint is on the boundary of the circle, and the point ray.p1 is inside/outside the circle)
      if ((this.isInsideGlass(ray.p1) || this.isOutsideGlass(ray.p1)) && this.isOnBoundary(incidentPoint)) // if the ray is hitting the circle from the outside, or from the inside (meaning that the point incidentPoint is on the boundary of the circle, and the point ray.p1 is inside/outside the circle)
      {
        console.log("ray incident exists.");
        let r_bodyMerging_obj = ray.bodyMergingObj; // save the current bodyMergingObj of the ray, to pass it later to the reflected ray in the 'refract' function

        var incidentData = this.getIncidentData(ray);
        var incidentType = incidentData.incidentType;
        if (incidentType == 1) {
          // From inside to outside
          var n1 = this.getRefIndexAt(incidentPoint, ray);
          this.onRayExit(ray);
          console.log("Incident type I");
        } else if (incidentType == -1) {
          // From outside to inside
          var n1 = 1 / this.getRefIndexAt(incidentPoint, ray);
          this.onRayEnter(ray);
          console.log("Incident type II");
        } else if (incidentType == 0) {
          // Equivalent to not intersecting with the object (e.g. two interfaces overlap)
          var n1 = 1;
          console.log("Incident type III");
        } else {
          // The situation that may cause bugs (e.g. incident on an edge point)
          // To prevent shooting the ray to a wrong direction, absorb the ray
          console.log("Incident type NULL");
          return {
            isAbsorbed: true
          };
        }
        console.log(
          "INCIDENT DATA:" + 
          "\n\tNormal:\t" + incidentData.normal.x + ", " + incidentData.normal.y + 
          "\n\tS_point:\t" + incidentData.s_point.x + ", " + incidentData.s_point.y + 
          "\n\tN1:\t" + n1
        );
        return this.refract(ray, rayIndex, incidentData.s_point, incidentData.normal, n1, surfaceMergingObjs, r_bodyMerging_obj);
      } else {
        if (ray.bodyMergingObj === undefined)
          ray.bodyMergingObj = this.initRefIndex(ray); // Initialize the bodyMerging object of the ray
        const next_point = this.step(ray.p1, incidentPoint, ray);
        ray.p1 = incidentPoint;
        ray.p2 = next_point;
      }
    } catch (e) {
      this.error = e.toString();
      console.log(this.error);
      return {
        isAbsorbed: true
      };
    }
  }

  getIncidentType(ray) {
    console.log("incidentType(" + ray + "):\t" + this.getIncidentData(ray).incidentType);
    return this.getIncidentData(ray).incidentType;
  }

  isOutsideGlass(point) {
    //console.log("isOutsideGlass(" + point + "):\t" + !this.isOnBoundary(point) && this.countIntersections(point) % 2 == 0);
    return (!this.isOnBoundary(point) && this.countIntersections(point) % 2 == 0)
  }

  isInsideGlass(point) {
    console.log("isInsideGlass():\t" + String(!this.isOnBoundary(point) && this.countIntersections(point) % 2 == 1) + "");
    return (!this.isOnBoundary(point) && this.countIntersections(point) % 2 == 1)
  }
  
  isOnBoundary(p3) {
    /* Old
    for (let i = 0; i < this.path.length; i++) {
      let p1 = this.path[i];
      let p2 = this.path[(i + 1) % this.path.length];
      let p1_p2 = geometry.point(p2.x - p1.x, p2.y - p1.y);
      let p1_p3 = geometry.point(p3.x - p1.x, p3.y - p1.y);
      if (geometry.cross(p1_p2, p1_p3) - this.intersectTol < 0 && geometry.cross(p1_p2, p1_p3) + this.intersectTol > 0) // if p1_p2 and p1_p3 are collinear
      {
        let dot_p2_p3 = geometry.dot(p1_p2, p1_p3);
        let p1_p2_squared = geometry.distanceSquared(p1, p2);
        if (p1_p2_squared - dot_p2_p3 + this.intersectTol >= 0 && dot_p2_p3 + this.intersectTol >= 0) // if the projection of the segment p1_p3 onto the segment p1_p2, is contained in the segment p1_p2
          return true;
      }
    }
    return false;*/

    // New (curve-oriented)
    for (let i = 0; i < this.path.length; i++) {
      /*closestPoint = this.curves[i].get(this.curves[i].project(geometry.point(p3.x, p3.y)).t);
      closestPoint = geometry.point(closestPoint.x, closestPoint.y);
      console.log("CURVE " + i + ": Tolerance:" + this.intersectTol);
      console.log("Closest point:\t" + closestPoint.x + ", " + closestPoint.y);
      console.log("Point given:\t" + p3.x + ", " + p3.y);
      console.log("Difference:\t" + (p3.x - closestPoint.x) + ", " + (p3.y - closestPoint.y));
      console.log("Distance:\t" + geometry.distance(geometry.point(p3.x, p3.y), closestPoint));*/

      // If the distance to the nearest point on the current curve from p3 is below the intersect tolerance threshold, p3 is on boundary
      if (this.curves[i].project(p3).d ** 2 <= this.intersectTol) {//(this.stepSize / this.rayLen)) {
        console.log("INTERSECTION" + this.curves[i].project(p3).d + "");
        return true;
      }
    }
    return false;
  }

  /* Utility methods */

  getIncidentData(ray) {
    var i = this.tmp_i;
    
    var intersections = this.curves[i].lineIntersects(geometry.scaleRayForCurve(ray, this.curves[i]));
    
    var s_point = { x: Infinity, y: Infinity, t: 0 };
    var s_point_tmp = s_point;

    // Get normal from the curve
    if (intersections.length >= 1) {
      s_point = this.curves[i].get(intersections[0]);
      
      // Get closest intersection on curve to current point (for when there are multiple intersections on the curve)
      intersections.forEach((intersection) => {
        s_point_tmp = this.curves[i].get(intersection);
        if (geometry.distance(geometry.point(s_point_tmp.x, s_point_tmp.y), geometry.point(ray.p1.x, ray.p1.y)) < geometry.distance(geometry.point(s_point.x, s_point.y), geometry.point(ray.p1.x, ray.p1.y))) {
          s_point = s_point_tmp;
        }
      });
    }

    var normal = this.curves[i].normal(s_point.t);
    normal = geometry.point(normal.x, normal.y);

    console.log(
      "NORMALS:" +
      "\n\tUnchanged:\t" + normal.x + ", " + normal.y +
      "\n\t+x, -y (in use):\t" + normal.x + ", " + (-normal.y) +
      "\n\t-x, -y:\t" + (-normal.x) + ", " + (-normal.y) +
      "\n\t-x, +y:\t" + (-normal.x) + ", " + (normal.y)
    )

    // Reorient tangent if necessary, to ensure it's on the same side of the curve as p1
    if (normal.x * (ray.p2.x - ray.p1.x) + normal.y * (ray.p2.y - ray.p1.y) > 0) {
      normal.x = -normal.x;
      normal.y = -normal.y;
    }/*
    if (normal.x * (ray.p2.x - ray.p1.x) + normal.y * (ray.p2.y - ray.p1.y) > 0) {
      normal.x = -normal.x;
      normal.y = normal.y;
    }*/

    if (this.isInsideGlass(ray.p1)) {
      var incidentType = 1; // Inside to outside
    } else {
      var incidentType = -1; // Outside to inside
    }

    return { s_point: s_point, normal: geometry.point(normal.x, normal.y), incidentType: incidentType }
  }

  getIncidentData_old(ray) {
    var s_lensq = Infinity;
    var s_lensq_temp;
    var s_point = null;
    var s_point_temp = null;
    var s_point_index;

    var surfaceMultiplicity = 1; // How many time the surfaces coincide

    var rp_temp;
    //var rp2_temp;
    var rp_temp_tmp;

    var normal_x;
    var normal_x_temp;

    var normal_y;
    var normal_y_temp;

    var rdots;
    var ssq;

    var nearEdge = false;
    var nearEdge_temp = false;

    //var ray2 = geometry.line(ray.p1, geometry.point(ray.p2.x + this.scene.rng() * 1e-5, ray.p2.y + this.scene.rng() * 1e-5)); // The ray to test the inside/outside (the test ray)
    var ray_intersect_count = 0; // The intersection count (odd means from outside)

    var intersections = null; // Bezier intersections
    var normal = null; // Normal using BezierJS

    for (var i = 0; i < this.path.length; i++) {
      rp_temp = { x: NaN, y: NaN };
      intersections = this.curves[i].intersects(geometry.line(ray.p1, ray.p2));
      ray_intersect_count += intersections.length;
      /*
      for (var j = 0; j < intersections.length; j++) {
        var normal = this.curves[i].normal(intersections[j]);
      }
      
      // Send out an error if number of intersections is greater than 1 for the current ray, indicating necessity of either decrease in tolerance or adjustment of lens geometry
      if (intersections.length > 1) {
        throw new Error(
          "CurveGrinGlass.js: getIncidentData():\n\tMultiple intersections with ray of length " + 
          String(geometry.length(ray)) + " with lens.\n\tConsider using a smaller ray length or adjusting your curved lens' geometry."
        );
      }*/
     
      // Get normal from the curve
      if (intersections.length >= 1) {
        // Get intersections of both rays with the curve in x,y coords
        rp_temp = this.curves[i].get(intersections[0]);
        //rp2_temp = this.curves[i].get(intersections.r2[0]);
        //rp_temp = geometry.point(rp_temp.x, rp_temp.y);
        //rp2_temp = geometry.point(rp2_temp.x, rp2_temp.y)
       
        // Get closest intersection on curve to current point (for when there are multiple intersections on the curve)
        intersections.forEach((intersection) => {
          rp_temp_tmp = this.curves[i].get(intersection);
          if (geometry.distance(geometry.point(rp_temp_tmp.x, rp_temp_tmp.y), geometry.point(ray.p1.x, ray.p1.y)) < geometry.distance(geometry.point(rp_temp.x, rp_temp.y), geometry.point(ray.p1.x, ray.p1.y))) {
            rp_temp = rp_temp_tmp;
          }
        });

        //rp_temp = geometry.linesIntersection(geometry.line(ray.p1, ray.p2), geometry.line(this.path[i % this.path.length], this.path[(i + 1) % this.path.length]));
        //rp2_temp = geometry.linesIntersection(geometry.line(ray2.p1, ray2.p2), geometry.line(this.path[i % this.path.length], this.path[(i + 1) % this.path.length]));
  
        console.log(geometry.point(rp_temp.x, rp_temp.y));
        //console.log(rp2_temp);
      }

      s_point_temp = null;
      nearEdge_temp = false;

      if (geometry.intersectionIsOnCurve(geometry.point(rp_temp.x, rp_temp.y), this.curves[i], this.intersectTol) && geometry.intersectionIsOnRay(geometry.point(rp_temp.x, rp_temp.y), ray) && geometry.distanceSquared(ray.p1, geometry.point(rp_temp.x, rp_temp.y)) > Simulator.MIN_RAY_SEGMENT_LENGTH_SQUARED * this.scene.lengthScale * this.scene.lengthScale) {
        s_lensq_temp = geometry.distanceSquared(ray.p1, geometry.point(rp_temp.x, rp_temp.y)); // Distance between first point of ray and point of intersection
        s_point_temp = geometry.point(rp_temp.x, rp_temp.y);

        /*
        rdots = (ray.p2.x - ray.p1.x) * (this.path[(i + 1) % this.path.length].x - this.path[i % this.path.length].x) + (ray.p2.y - ray.p1.y) * (this.path[(i + 1) % this.path.length].y - this.path[i % this.path.length].y);
        ssq = (this.path[(i + 1) % this.path.length].x - this.path[i % this.path.length].x) * (this.path[(i + 1) % this.path.length].x - this.path[i % this.path.length].x) + (this.path[(i + 1) % this.path.length].y - this.path[i % this.path.length].y) * (this.path[(i + 1) % this.path.length].y - this.path[i % this.path.length].y);

        normal_x_temp = rdots * (this.path[(i + 1) % this.path.length].x - this.path[i % this.path.length].x) - ssq * (ray.p2.x - ray.p1.x);
        normal_y_temp = rdots * (this.path[(i + 1) % this.path.length].y - this.path[i % this.path.length].y) - ssq * (ray.p2.y - ray.p1.y);
        */

        normal = this.curves[i].normal(rp_temp.t);

        console.log("NORMAL: " + normal.x + ", " + normal.y);

        normal_x = normal.x;
        normal_y = normal.y;

      }

      /*if (geometry.intersectionIsOnSegment(rp2_temp, geometry.line(this.path[i % this.path.length], this.path[(i + 1) % this.path.length])) && geometry.intersectionIsOnRay(rp2_temp, ray2) && geometry.distanceSquared(ray2.p1, rp2_temp) > Simulator.MIN_RAY_SEGMENT_LENGTH_SQUARED * this.scene.lengthScale * this.scene.lengthScale) {
        ray_intersect_count++;
      }*/

      // Test if too close to an edge. Can use default without accounting for curves because this tests for proximity to bounding points of the curve, not the curve itself, and those bounding points are the same as those for a straight line.
      if (s_point_temp && (geometry.distanceSquared(s_point_temp, this.path[i % this.path.length]) < Simulator.MIN_RAY_SEGMENT_LENGTH_SQUARED * this.scene.lengthScale * this.scene.lengthScale || geometry.distanceSquared(s_point_temp, this.path[(i + 1) % this.path.length]) < Simulator.MIN_RAY_SEGMENT_LENGTH_SQUARED * this.scene.lengthScale * this.scene.lengthScale)) {
        nearEdge_temp = true;
      }
      
      if (s_point_temp) {
        if (s_point && geometry.distanceSquared(s_point_temp, s_point) < Simulator.MIN_RAY_SEGMENT_LENGTH_SQUARED * this.scene.lengthScale * this.scene.lengthScale) {
          // Self surface merging
          surfaceMultiplicity++;
        } else if (s_lensq_temp < s_lensq) {
          s_lensq = s_lensq_temp;
          s_point = s_point_temp;
          s_point_index = i;
          normal_x = normal_x_temp;
          normal_y = normal_y_temp;
          nearEdge = nearEdge_temp;
          surfaceMultiplicity = 1;
        }
      }
    }


    if (nearEdge) {
      var incidentType = NaN; // Incident on an edge point
      console.log("NEAR EDGE");
    } else if (surfaceMultiplicity % 2 == 0) {
      var incidentType = 0; // Equivalent to not intersecting with the object
      console.log("NO INTERACTION");
    } else if (ray_intersect_count % 2 == 1) {
      var incidentType = 1; // From inside to outside
      console.log("INSIDE OUT");
    } else {
      console.log("OUTSIDE IN");
      var incidentType = -1; // From outside to inside
    }

    return { s_point: s_point, normal: { x: normal_x, y: normal_y }, incidentType: incidentType };
  }

  // Implementation of the "crossing number algorithm" (see - https://en.wikipedia.org/wiki/Point_in_polygon)
  // Using p3 and (0, 0), since it shouldn't make a difference what the second point is for just getting even or odd to find out if in or out of object.
  countIntersections(p3) {
    
    var cnt = 0;
    for (let i = 0; i < this.path.length; i++) {
      // Add the number of intersections found on the current curve from p3 to (0, 0)
      cnt += this.curves[i].intersects(geometry.line(geometry.point(p3.x, p3.y), {x: 0, y: 0})).length;// ? 1 : 0;
    }
    return cnt; // Returns the number of intersections between a horizontal ray (that originates from the point - p3) and the Free-shape glass object - this.
  }

  // Generate default control points from path (helper method)
  generateDefaultControlPoints(prev, cur, next) {
    //var line = geometry.parallelLineThroughPoint(geometry.line(prev, next), cur);
    const nextMidpoint = geometry.segmentMidpoint(geometry.line(cur, next));
    const prevMidpoint = geometry.segmentMidpoint(geometry.line(prev, cur));

    const nextLine = geometry.orthoProj(geometry.line(cur, nextMidpoint), geometry.line(prev, next));
    const prevLine = geometry.orthoProj(geometry.line(prevMidpoint, cur), geometry.line(next, prev));

    return [ geometry.point(cur.x + prevLine.p2.x - prevLine.p1.x, cur.y + prevLine.p2.y - prevLine.p1.y), geometry.point(cur.x + nextLine.p2.x - nextLine.p1.x, cur.y + nextLine.p2.y - nextLine.p1.y) ];
  }

  // Generate Poly Bezier from path
  generatePolyBezier() {
    this.curves = [];
    // Create one curve for each line
    for (var i = 0; i < this.path.length; i++) {
      let curCtrlPts = this.generateDefaultControlPoints(this.path[(i - 1 + this.path.length) % this.path.length], this.path[i], this.path[(i + 1) % this.path.length])
      this.curves.push(new Bezier(this.path[i], curCtrlPts[0], curCtrlPts[1], this.path[(i + 1) % this.path.length]));
      //this.drawCurve(this.curves[i], this.path[i], canvasRenderer);
    }
    //this.polyBezier = new PolyBezier(this.curves);
  }

  // Draw curve
  drawCurve(curve, offset, canvasRenderer) {
    const ctx = canvasRenderer.ctx;
    var p = curve.points;
    ctx.strokeStyle = 'rgb(128,128,128)';
    ctx.beginPath();
    //ctx.moveTo(p[0].x + offset.x, p[0].y + offset.y);
    ctx.moveTo(p[0].x, p[0].y);
    //ctx.bezierCurveTo(p[1].x + offset.x, p[1].y + offset.y, p[2].x + offset.x, p[2].y + offset.y, p[3].x + offset.x, p[3].y + offset.y);
    ctx.bezierCurveTo(p[1].x, p[1].y, p[2].x, p[2].y, p[3].x, p[3].y);
    ctx.stroke();
    ctx.closePath();

    ctx.strokeStyle = 'rgb(255,0,0)';
    this.drawLine(p[0], p[1], offset, canvasRenderer);
    this.drawLine(p[2], p[3], offset, canvasRenderer);

    ctx.fillStyle = 'rgb(255,0,0)';
    p.forEach((cur) => this.drawPoint(cur, canvasRenderer));
  }

  // Draw line
  drawLine(p1, p2, offset, canvasRenderer) {
    const ctx = canvasRenderer.ctx;
    ctx.beginPath();
    //ctx.moveTo(p1.x + offset.x, p1.y + offset.y);
    //ctx.lineTo(p2.x + offset.x, p2.y + offset.y);
    ctx.moveTo(p1.x, p1.y);
    ctx.lineTo(p2.x, p2.y);
    ctx.stroke();
  }

  // Draw point
  drawPoint(p1, canvasRenderer) {
    const ctx = canvasRenderer.ctx;
    const ls = canvasRenderer.lengthScale;
    ctx.fillRect(p1.x - 1.5 * ls, p1.y - 1.5 * ls, 3 * ls, 3 * ls);
  }
};

export default CurveGrinGlass;